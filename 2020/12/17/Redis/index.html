<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis | luxnln</title><meta name="keywords" content="Redis"><meta name="author" content="Luxnln"><meta name="copyright" content="Luxnln"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介Redis是一个开源(BSD许可)，高性能的非关系型(NoSQL)数据库(key-value数据库)。数据是存储在内存中的，当然它能够将内存中的数据保存到磁盘中，等重启再重新加载到内存。 Redis常用作数据库，缓存和消息代理。 Redis提供了许多数据结构，例如：**strings(字符串)、hashes(散列)、lists(列表)、sets(集合)、sorted sets(带范围查询的排序">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://github.com/luxnln/luxnln.github.io/2020/12/17/Redis/index.html">
<meta property="og:site_name" content="luxnln">
<meta property="og:description" content="简介Redis是一个开源(BSD许可)，高性能的非关系型(NoSQL)数据库(key-value数据库)。数据是存储在内存中的，当然它能够将内存中的数据保存到磁盘中，等重启再重新加载到内存。 Redis常用作数据库，缓存和消息代理。 Redis提供了许多数据结构，例如：**strings(字符串)、hashes(散列)、lists(列表)、sets(集合)、sorted sets(带范围查询的排序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover2.png">
<meta property="article:published_time" content="2020-12-17T01:18:12.000Z">
<meta property="article:modified_time" content="2020-12-17T10:59:27.046Z">
<meta property="article:author" content="Luxnln">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/luxnln/luxnln.github.io/2020/12/17/Redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-8FB8GQC3GE"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-8FB8GQC3GE');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"6X03TQYT9L","apiKey":"727f7c62fe6e346f4448d0f80914ab79","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":75,"languages":{"author":"作者: Luxnln","link":"链接: ","source":"来源: luxnln","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-17 18:59:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/mystyle.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/head/rocket.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">luxnln</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-17T01:18:12.000Z" title="发表于 2020-12-17 09:18:12">2020-12-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-17T10:59:27.046Z" title="更新于 2020-12-17 18:59:27">2020-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2020/12/17/Redis/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2020/12/17/Redis/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis是一个开源(BSD许可)，高性能的非关系型(NoSQL)数据库(key-value数据库)。数据是存储在内存中的，当然它能够将内存中的数据保存到磁盘中，等重启再重新加载到内存。</p>
<p>Redis常用作数据库，缓存和消息代理。</p>
<p>Redis提供了许多数据结构，例如：**strings(字符串)、hashes(散列)、lists(列表)、sets(集合)、sorted sets(带范围查询的排序集合)**、bitmaps(位图)、hyperloglogs(超重对数)、geospatial indexes(seo，地理空间索引)和streams(流)等。</p>
<p>Redis内置复制、Lua脚本、LRU(最近最久未使用算法)回收、事务和不同级别的磁盘持久性，并提供高可用的Redis Sentinel(哨兵)和Redis集群的自动分区。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>性能高；</li>
<li>丰富的数据类型；</li>
<li>原子性；</li>
<li>丰富的特性。</li>
</ol>
<h2 id="Redis-键-keys"><a href="#Redis-键-keys" class="headerlink" title="Redis 键(keys)"></a>Redis 键(keys)</h2><p>Redis的键是binary safe的，这表明我们可以用任意得二进制序列(binary sequence)作为键，无论是字符串还是图片文件的内容，包括空串也可以作为键。</p>
<p><strong>基本语法</strong>：<code>COMMAND KEY_NAME</code></p>
<p>例如：<code>set key1 value1</code>，<strong>set</strong>是命令，<strong>key1</strong>是一个键，<strong>value1</strong>是键对应的值。这个命令的作用就是保存键为key1，值为value1的键值对数据。</p>
<p><strong>基本命令</strong>：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>del key</code></td>
<td>该命令用于在 key 存在时删除 key。</td>
</tr>
<tr>
<td><code>dump key</code></td>
<td>序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr>
<td><code>exists key</code></td>
<td>检查给定 key 是否存在。</td>
</tr>
<tr>
<td><code>type key</code></td>
<td>返回key所存储的值的类型。</td>
</tr>
<tr>
<td><code>keys pattern</code></td>
<td>查找所有符合给定模式( pattern)的 key 。</td>
</tr>
<tr>
<td><code>rename key newkey</code></td>
<td>修改key的名称。</td>
</tr>
<tr>
<td><code>renamenx key newkey</code></td>
<td>修改key的名称，仅当new可以不存在时生效。</td>
</tr>
<tr>
<td><code>expire key seconds</code></td>
<td>为给定 key 设置过期时间，以秒为单位。</td>
</tr>
<tr>
<td><code>pexpipre key milliseconds</code></td>
<td>为给定 key 设置过期时间，以毫秒为单位。</td>
</tr>
<tr>
<td><code>expireat key timestamp</code></td>
<td>为给定 key 设置过期时间，指定过期时间戳。</td>
</tr>
<tr>
<td><code>pexpireat key ms-timestamp</code></td>
<td>为给定 key 设置过期时间，指定过期时间戳一毫秒为单位。</td>
</tr>
<tr>
<td><code>persist key</code></td>
<td>移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr>
<td><code>tell key</code></td>
<td>返回key的剩余时间。返回-2，表示key不存在；返回-2，表示没有设置过期时间。</td>
</tr>
</tbody></table>
<p><strong>关于键命名的一些规则</strong>：</p>
<ol>
<li>键命名不适合特别长。例如：命名一个1024字节的key这种就不太合适。如果需要匹配在一些特别长或大的值的话，用它们的散列或许会更合适；</li>
<li>键命名也不宜太短。例如：”u1000flw”作为关键字，它的表意并不清晰，换成”user:1000:followers”或许更合适；</li>
<li>坚持键命名格式统一。例如：”object-type:id”-&gt;”user:1000”。使用<code>.</code>或者<code>-</code>来表示短语，例如：<code>comment:1234:reply.to</code>或者<code>comment:1234:reply-to</code>；</li>
<li>key允许的最大值为512MB。</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="strings-字符串"><a href="#strings-字符串" class="headerlink" title="strings(字符串)"></a>strings(字符串)</h3><p>字符串可以通过<strong>set</strong>和<strong>get</strong>命令来进行设置和获取。</p>
<p>字符串作为key，其对应的value可以是任意的类型。</p>
<p>字符串最大不超过512MB。</p>
<p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; set mykey somevalue</span><br><span class="line">OK</span><br><span class="line">&gt; get mykey</span><br><span class="line">&quot;somevalue&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用set时，如果键已经存在了，那么会把原来的value给覆盖。如果不想让它覆盖，而是当key已存在时，set操作失败，则可以添加<code>nx</code>参数。例如：<code>set mykey newvalue nx</code></p>
</blockquote>
<p>如果想要同时设置或获取多个键值，那么也可以使用<a target="_blank" rel="noopener" href="https://redis.io/commands/mset">mset</a>和<a target="_blank" rel="noopener" href="https://redis.io/commands/mget">mget</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; mset a 10 b 20 c 30</span><br><span class="line">OK</span><br><span class="line">&gt; mget a b c</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;30&quot;</span><br></pre></td></tr></table></figure>



<p>Redis还提供了数字字符串解析相关的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set count 100</span><br><span class="line">OK</span><br><span class="line">&gt; incr count</span><br><span class="line">(integer) 101</span><br><span class="line">&gt; incr count</span><br><span class="line">(integer) 102</span><br><span class="line">&gt; type count</span><br><span class="line">string</span><br></pre></td></tr></table></figure>



<p><code>incr</code>命令使字符串解析为数值并对其加1，当然value最后还是字符串类型的。</p>
<blockquote>
<p>incr命令是<strong>原子的</strong>。</p>
<p>使用incr命令，如果key对应的值不是数字，那么就会报错。</p>
</blockquote>
<blockquote>
<p>还有其它命令，诸如<a target="_blank" rel="noopener" href="https://redis.io/commands/incrby">incrby</a>，<a target="_blank" rel="noopener" href="https://redis.io/commands/decr">decr</a>和<a target="_blank" rel="noopener" href="https://redis.io/commands/decrby">decrby</a>，它们的都能对数字进行操作，但是，它们的操作结果会有区别。</p>
</blockquote>
<h3 id="lists-列表"><a href="#lists-列表" class="headerlink" title="lists(列表)"></a>lists(列表)</h3><p>Redis的列表是用链表实现的。</p>
<p>我们可以从列表的头或尾插入取出数据。</p>
<p>Redis的一个列表中最多可以包含 2<sup>32</sup> - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<p>Redis列表中的元素可以是不同的类型。</p>
<p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist a</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush mylist b</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; lpush mylist first</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;first&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;b&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>lpush</code>命令，将元素添加到列表的左边(头部)；</p>
<p><code>rpush</code>命令，将元素添加到列表的右边(尾部)；</p>
<p><code>lrange</code>命令，从指定列表中取出指定范围的元素，-1表示最后一个数(倒数第一个)，-2则表示倒数第二个数，指定范围：[n, m]，左闭右闭。</p>
</blockquote>
<p><code>lpush</code>和<code>rpush</code>是可变命令，即可以指定多个值，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylish 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; lpush mylish 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; lrange mylish 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;2&quot;</span><br></pre></td></tr></table></figure>



<p>查看lists的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; llen mylish</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>



<p>通过索引获取列表中的元素或是设置对应的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;lpush list 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; lindex list 2</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&gt; lset list 2 6</span><br><span class="line">OK</span><br><span class="line">&gt; lrange list 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>lindex</code>：取出指定索引的元素；</p>
<p><code>lset</code>：设置指定索引的值。如果指定索引超出范围，则会报错。</p>
</blockquote>
<p>我们可以像双向队列那样对列表进行弹出(pop)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylish 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">&gt; rpop mylish</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&gt; lrange mylish 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;1&quot;</span><br><span class="line">&gt; lpop mylish</span><br><span class="line">&quot;4&quot;</span><br><span class="line">&gt; lrange mylish 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>lpop和rpop，从列表中头部或尾部<strong>取出</strong>值。</p>
<p>如果列表为空，则返回null。</p>
</blockquote>
<p>Redis的lists也支持截取操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">&gt; ltrim mylist 0 2</span><br><span class="line">OK</span><br><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p><code>ltrim</code>截取指定范围(*[起始下标，结束下标]*，左闭右闭)的值，其余部分将会被删除。</p>
<p>Redis的lists还提供了阻塞操作。</p>
<blockquote>
<p>当lists为空的时候<code>lpop</code>和<code>rpop</code>操作就会立马返回null。调用者只能等待一段时间，然后轮询调用。这会导致Redis和调用者都会重复的处理无用的命令。</p>
<p>所以Redis提供了<code>blpop</code>和<code>brpop</code>，当lists为空的时候，pop操作为不会立马返回null，而是会等待一段时间，如果还没有才返回null。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; brpop mylist 5</span><br><span class="line">(nil)</span><br><span class="line">(5.05s)</span><br></pre></td></tr></table></figure>

<p>上述命令，表示尝试从mylist中弹出元素，若是mylist为空，则等待5s。5s后还是没有元素，则返回null。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>可以使用0来表示永久等待。</li>
<li>可以指定多个列表，第一个lists不为空，则弹出第一个lists的元素；若是第一个lists为空，则弹出第二个lists中的元素；若是都为空，则等待。等待期间若是有lists添加了元素，则将其弹出。否则返回null。</li>
<li><code>blpop</code>、<code>brpop</code>和<code>lpop</code>、<code>rpop</code>的返回值是不一样的，<code>blpop</code>和<code>brpop</code>返回是有两个元素的lists。</li>
</ol>
</blockquote>
<blockquote>
<p>其它：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://redis.io/commands/lmove">lmove</a>：移动lists第一个或最后一个元素到另一个lists的头部或尾部</li>
<li><a target="_blank" rel="noopener" href="https://redis.io/commands/blmove">bmove</a>：阻塞的方式实现lmove的功能。</li>
</ol>
</blockquote>
<p>自动创建与销毁：</p>
<ul>
<li>当我们push一个值到不存在的keys时，会在添加之前自动创建。</li>
<li>当keys为空时，会自动删除keys。</li>
</ul>
<p>当然，要注意的是，相关命令需要与对应数据类型的对应。不能对错误类型进行操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">&gt; lpush foo 1 2 3</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">&gt; type foo</span><br><span class="line">string</span><br></pre></td></tr></table></figure>



<h3 id="hashes-散列"><a href="#hashes-散列" class="headerlink" title="hashes(散列)"></a>hashes(散列)</h3><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 2<sup>32</sup> - 1 键值对（40多亿）。</p>
<p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset user:100 username antirez birthyear 1977 verified 1</span><br><span class="line">OK</span><br><span class="line">&gt; hget user:100 username</span><br><span class="line">&quot;antirez&quot;</span><br><span class="line">&gt; hget user:100 birthyear</span><br><span class="line">&quot;1977&quot;</span><br><span class="line">&gt; hget user:100 verified</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&gt; hgetall user:100</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;birthyear&quot;</span><br><span class="line">4) &quot;1977&quot;</span><br><span class="line">5) &quot;verified&quot;</span><br><span class="line">6) &quot;1&quot;</span><br><span class="line">&gt; del user:100</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>hmset</code>：设置hashes类型的数据；</p>
<p><code>hmget</code>：可以获取hashes中的值，并且可以指定多个键，例如：hget user:100 username birthyear；</p>
<p><code>hgetall</code>：获取hashes里面的所有数据；</p>
<p><code>hdel</code>：删除hashes中指定的字段。</p>
</blockquote>
<p>更多命令请参考<a target="_blank" rel="noopener" href="https://redis.io/commands#hash">redis.io</a>，或者<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-hashes.html">菜鸟教程</a></p>
<h3 id="sets-集合"><a href="#sets-集合" class="headerlink" title="sets(集合)"></a>sets(集合)</h3><p>Redis 的 Sets 是 strings 类型的无序集合。</p>
<p>Redis的sets成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>Redis的sets中最大的成员数为 2<sup>32</sup> - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd myset 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; smembers myset</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">&gt; srem myset 2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>sadd</code>：添加一个sets数据；</p>
<p><code>smembers</code>：查看sets的内容；</p>
<p><code>srem</code>：移除指定的元素。</p>
</blockquote>
<p>如果看sets中是否存在某个元素，可以使用<code>sismember</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sismember myset 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember myset 4</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>



<p>随机地从sets中<strong>弹出</strong>一个元素，使用<code>spop</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 SJ SQ SK</span><br><span class="line">(integer) 52</span><br><span class="line">&gt; spop deck 5</span><br><span class="line">1) &quot;C2&quot;</span><br><span class="line">2) &quot;C5&quot;</span><br><span class="line">3) &quot;D10&quot;</span><br><span class="line">4) &quot;S3&quot;</span><br><span class="line">5) &quot;S4&quot;</span><br></pre></td></tr></table></figure>



<p>取并集，使用<code>sunionstore</code>或者<code>sunion</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; sadd set2 3 4 5</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; sadd set3 6</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sunion set3 set1 set2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">&gt; sunionstore set3 set1 set2</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>sunion</code>：是取所有指定集合的并集，返回值是并集;</p>
<p><code>sunionstroe</code>：以上述为例，将set1和set2的并集放入set3中，如果set3已存在，则覆盖之。返回值是并集的长度；</p>
<p>这两个指令也可以对一个集合取并集，即就是其本身。</p>
</blockquote>
<p>如果你想从集合中随机获取一个元素，并不中集合中删除，那么可以使用<a target="_blank" rel="noopener" href="https://redis.io/commands/srandmember"><code>srandmember</code></a>命令；</p>
<h3 id="sorted-sets-带范围查询的排序集合"><a href="#sorted-sets-带范围查询的排序集合" class="headerlink" title="sorted sets(带范围查询的排序集合)"></a>sorted sets(带范围查询的排序集合)</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。Redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p> 集合中最大的成员数为 2<sup>32</sup> - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd hackers 1940 &quot;Alan Kay&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd hackers 1957 &quot;Sophie Wilson&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd hackers 1953 &quot;Richard Stallman&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd hackers 1949 &quot;Anita Borg&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd hackers 1916 &quot;Claude Shannon&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange hackers 0 -1</span><br><span class="line">1) &quot;Claude Shannon&quot;</span><br><span class="line">2) &quot;Alan Kay&quot;</span><br><span class="line">3) &quot;Anita Borg&quot;</span><br><span class="line">4) &quot;Richard Stallman&quot;</span><br><span class="line">5) &quot;Sophie Wilson&quot;</span><br><span class="line">&gt; zrem hackers &quot;Anita Borg&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>zadd</code>：添加一个sorted sets数据，如果元素已存在，则覆盖其score。示例中1940是一个分数(score)，用于排序。这个操作需要O(logN);</p>
<p><code>zrem</code>：删除指定元素。</p>
<p><code>zrange</code>：取出指定范围的数据。如果想连带分数一起输出的话可以代<code>withscores</code>参数，例如：<code>zrange hackers 0 -1 withscores</code>。</p>
<p>如果想逆序输出，可以使用<code>zrevrange</code>。</p>
</blockquote>
<p>如果你想按score范围查询，则可以使用<code>zrangebyscore</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrangebyscore hackers -inf 1950</span><br><span class="line">1) &quot;Claude Shannon&quot;</span><br><span class="line">2) &quot;Alan Kay&quot;</span><br><span class="line">3) &quot;Anita Borg&quot;</span><br><span class="line">&gt; zrangebyscore hackers 1940 1950</span><br><span class="line">1) &quot;Alan Kay&quot;</span><br><span class="line">2) &quot;Anita Borg&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-inf：负无穷大</p>
</blockquote>
<p>也可以按score范围删除，使用<code>zremrangebyscore</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zremrangebyscore hackers 1940 1950</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>



<p>如果我们想某个元素在sorted sets中的位置，可以使用<code>zrank</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrank hackers &quot;Richard Stallman&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrank hackers &quot;abc&quot;</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想知道是逆序的第几个，则可以使用<code>zrevrank</code>命令。</p>
</blockquote>
<blockquote>
<p>注意：如果分数一样，则比较字符串，按字典的顺序。</p>
</blockquote>
<h3 id="geospatial-indexes-seo，地理空间索引"><a href="#geospatial-indexes-seo，地理空间索引" class="headerlink" title="geospatial indexes(seo，地理空间索引)"></a>geospatial indexes(seo，地理空间索引)</h3><p>请参考<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html">菜鸟教程_Redis</a>。</p>
<h3 id="streams-流"><a href="#streams-流" class="headerlink" title="streams(流)"></a>streams(流)</h3><p>请参考<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-stream.html">菜鸟教程_Redis</a>。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p>
<p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<h3 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h3><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h2 id="Redis与memcached对比"><a href="#Redis与memcached对比" class="headerlink" title="Redis与memcached对比"></a>Redis与memcached对比</h2><p><strong>两者都是非关系型内存键值数据库</strong>，不同点在于：</p>
<ol>
<li><p><strong>数据类型</strong>。Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题；</p>
</li>
<li><p><strong>数据持久化</strong>。Memcached 不支持持久化，而Redis 支持两种持久化策略：RDB 快照和 AOF 日志；</p>
</li>
<li><p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点；</li>
<li>Redis Cluster 实现了分布式的支持；</li>
</ul>
</li>
<li><p><strong>内存管理机制</strong></p>
<ul>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了；</li>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中；</li>
</ul>
</li>
</ol>
<h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><p>Redis可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis具体有6种淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td>noeviction</td>
<td>禁止驱逐数据</td>
</tr>
</tbody></table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<blockquote>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
</blockquote>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量很大，保存快照的时间会很长。</p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<ul>
<li>always：每个写命令都同步。该选项会严重降低服务器的性能；</li>
<li>eversec：每秒同步一次。该选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no：让操作系统来决定何时同步。该选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<blockquote>
<p>随着服务器下请求的增多，AOF文件会越来越大。Redis提供了一种AOF重写的特性，能够取出AOF文件中冗余的写命令。</p>
</blockquote>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<blockquote>
<p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p>
</blockquote>
<p>但是，Redis的事务不具备原子性。在事务执行过程中，如是若是中间有指令执行失败，既不会导致前面已执行成功的指令回滚，也不会影响到后续执行正常执行。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; set a aaa</span><br><span class="line">QUEUED</span><br><span class="line">&gt; set b bbb</span><br><span class="line">QUEUED</span><br><span class="line">&gt; set c ccc</span><br><span class="line">QUEUED</span><br><span class="line">&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure>



<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis 服务器是一个事件驱动程序。</p>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象</p>
<p>时间事件又分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p>
<h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol>
<li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
<h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<h2 id="Sentinel（哨兵）"><a href="#Sentinel（哨兵）" class="headerlink" title="Sentinel（哨兵）"></a>Sentinel（哨兵）</h2><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0<del>1000 的存储到实例 R0 中，用户 id 从 1001</del>2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/data-types-intro"> http://redis.io/topics/data-types-intro</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟教程_Redis</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md">CS-Notes/Redis</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Luxnln</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/luxnln/luxnln.github.io/2020/12/17/Redis/">https://github.com/luxnln/luxnln.github.io/2020/12/17/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/luxnln/luxnln.github.io" target="_blank">luxnln</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">装饰者模式</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/15/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">原型模式</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/head/rocket.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Luxnln</div><div class="author-info__description">一只奋斗的咸鱼</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/luxnln/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/luxnln" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a><a class="social-icon" href="mailto:luxinlin.las@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">一只年轻的博客~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E9%94%AE-keys"><span class="toc-number">2.</span> <span class="toc-text">Redis 键(keys)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#strings-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.1.</span> <span class="toc-text">strings(字符串)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lists-%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">lists(列表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashes-%E6%95%A3%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">hashes(散列)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sets-%E9%9B%86%E5%90%88"><span class="toc-number">3.4.</span> <span class="toc-text">sets(集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted-sets-%E5%B8%A6%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%8E%92%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">3.5.</span> <span class="toc-text">sorted sets(带范围查询的排序集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geospatial-indexes-seo%EF%BC%8C%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95"><span class="toc-number">3.6.</span> <span class="toc-text">geospatial indexes(seo，地理空间索引)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#streams-%E6%B5%81"><span class="toc-number">3.7.</span> <span class="toc-text">streams(流)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">查找表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.4.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%BC%93%E5%AD%98"><span class="toc-number">4.5.</span> <span class="toc-text">会话缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.</span> <span class="toc-text">分布式锁实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">4.7.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%8Ememcached%E5%AF%B9%E6%AF%94"><span class="toc-number">5.</span> <span class="toc-text">Redis与memcached对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">6.</span> <span class="toc-text">数据淘汰策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">RDB持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">AOF持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">8.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.1.</span> <span class="toc-text">文件事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.2.</span> <span class="toc-text">时间事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">9.3.</span> <span class="toc-text">事件的调度与执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">10.1.</span> <span class="toc-text">连接过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E9%93%BE"><span class="toc-number">10.2.</span> <span class="toc-text">主从链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sentinel%EF%BC%88%E5%93%A8%E5%85%B5%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">Sentinel（哨兵）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-number">12.</span> <span class="toc-text">分片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">13.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/03/01/springboot2%E7%AC%94%E8%AE%B0/" title="Springboot2 学习笔记"><img src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot2 学习笔记"/></a><div class="content"><a class="title" href="/2021/03/01/springboot2%E7%AC%94%E8%AE%B0/" title="Springboot2 学习笔记">Springboot2 学习笔记</a><time datetime="2021-03-01T01:26:40.970Z" title="发表于 2021-03-01 09:26:40">2021-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/02/27/%E5%88%86%E9%A1%B5%E6%9D%A1%E6%A8%A1%E6%9D%BF/" title="分页条模板"><img src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover23.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分页条模板"/></a><div class="content"><a class="title" href="/2021/02/27/%E5%88%86%E9%A1%B5%E6%9D%A1%E6%A8%A1%E6%9D%BF/" title="分页条模板">分页条模板</a><time datetime="2021-02-27T02:04:02.000Z" title="发表于 2021-02-27 10:04:02">2021-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/11/MyBatis%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="MyBatis入门笔记"><img src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis入门笔记"/></a><div class="content"><a class="title" href="/2021/01/11/MyBatis%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="MyBatis入门笔记">MyBatis入门笔记</a><time datetime="2021-01-11T01:54:11.000Z" title="发表于 2021-01-11 09:54:11">2021-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/08/SpringMVC%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="SpringMVC入门笔记"><img src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC入门笔记"/></a><div class="content"><a class="title" href="/2021/01/08/SpringMVC%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="SpringMVC入门笔记">SpringMVC入门笔记</a><time datetime="2021-01-08T01:15:07.000Z" title="发表于 2021-01-08 09:15:07">2021-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/06/Spring5%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="Spring5入门笔记"><img src="https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring5入门笔记"/></a><div class="content"><a class="title" href="/2021/01/06/Spring5%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" title="Spring5入门笔记">Spring5入门笔记</a><time datetime="2021-01-06T03:35:08.000Z" title="发表于 2021-01-06 11:35:08">2021-01-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/luxnln/cdn@main/img/cover/cover2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Luxnln</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的<a target="_blank" rel="noopener" href="https://luxnln.github.io/">博客</a>一起学习！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'uytqObeeku5pIvOuSPbKavBQ-gzGzoHsz',
      appKey: 'maDLKIIafoz3vsD2TiHgCsbF',
      placeholder: '记得留下你的匿名和邮箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '4ca1b3485559d9a57698',
      clientSecret: '83103a3948d3dbe29eb820c515968f4813c93f0c',
      repo: 'for-gitalk',
      owner: 'luxnln',
      admin: ['luxnln'],
      id: '19ab15740dbfaeebe34b5c0fc07951da',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Valine' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>